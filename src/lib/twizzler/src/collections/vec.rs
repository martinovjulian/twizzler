use std::{
    alloc::Layout,
    mem::MaybeUninit,
    ops::{Index, IndexMut},
};

use twizzler_abi::object::{MAX_SIZE, NULLPAGE_SIZE};

use crate::{
    alloc::{Allocator, SingleObjectAllocator},
    marker::{BaseType, Invariant, Storable, StoreCopy},
    object::ObjectBuilder,
    ptr::{InvPtr, Ref, RefMut, RefSlice, RefSliceMut},
    tx::{Result, TxCell, TxHandle},
};

pub struct VecInner<T: Invariant> {
    len: usize,
    cap: usize,
    start: InvPtr<T>,
}

pub struct Vec<T: Invariant, Alloc: Allocator> {
    inner: TxCell<VecInner<T>>,
    alloc: Alloc,
}

pub struct VecObjectAlloc;

impl Allocator for VecObjectAlloc {
    fn alloc(
        &self,
        layout: Layout,
    ) -> std::result::Result<crate::ptr::GlobalPtr<u8>, std::alloc::AllocError> {
        todo!()
    }

    unsafe fn dealloc(&self, ptr: crate::ptr::GlobalPtr<u8>, layout: Layout) {
        todo!()
    }
}

impl SingleObjectAllocator for VecObjectAlloc {}

impl<T: Invariant, A: Allocator> BaseType for Vec<T, A> {}

impl<T: Invariant, Alloc: Allocator> Vec<T, Alloc> {
    pub fn get<'a>(&'a self, idx: usize) -> Option<Ref<'a, T>> {
        let r = self.inner.start.resolve();
        let slice = unsafe { RefSlice::from_ref(r, self.inner.len) };
        slice.get(idx)
    }

    pub fn new_inplace(place: &mut MaybeUninit<Self>, alloc: Alloc) -> crate::tx::Result<()> {
        todo!()
    }
}

impl<T: Invariant, Alloc: Allocator + SingleObjectAllocator> Vec<T, Alloc> {
    pub fn new_in(alloc: Alloc) -> Storable<Self> {
        let offset = size_of::<Self>().next_multiple_of(align_of::<T>());
        unsafe {
            Storable::new(Self {
                inner: TxCell::new(VecInner {
                    cap: 0,
                    len: 0,
                    start: InvPtr::from_raw_parts(0, offset as u64),
                }),
                alloc,
            })
        }
    }

    pub fn push(&self, item: T, tx: &impl TxHandle) -> Result<()> {
        if self.inner.len == self.inner.cap {
            if self.inner.start.raw() as usize + size_of::<T>() * self.inner.cap
                >= MAX_SIZE - NULLPAGE_SIZE
            {
                return Err(crate::tx::TxError::Exhausted);
            }
            self.inner.get_mut(tx)?.cap += 1;
        }
        // get start slice
        let mut r = unsafe {
            RefSliceMut::from_ref(
                self.inner
                    .start
                    .resolve()
                    .cast::<MaybeUninit<T>>()
                    .mutable(),
                self.inner.cap,
            )
        };
        // write item, tracking in tx
        tx.write_uninit(&mut r[self.inner.len], item)?;
        self.inner.get_mut(tx)?.len += 1;
        Ok(())
    }

    pub fn push_inplace<F, Tx>(&self, f: F, tx: &Tx) -> Result<()>
    where
        F: FnOnce(&mut MaybeUninit<T>) -> crate::tx::Result<()>,
        Tx: TxHandle,
    {
        if self.inner.len == self.inner.cap {
            if self.inner.start.raw() as usize + size_of::<T>() * self.inner.cap
                >= MAX_SIZE - NULLPAGE_SIZE
            {
                return Err(crate::tx::TxError::Exhausted);
            }
            self.inner.get_mut(tx)?.cap += 1;
        }
        // get start slice
        let mut r = unsafe {
            RefSliceMut::from_ref(
                self.inner
                    .start
                    .resolve()
                    .cast::<MaybeUninit<T>>()
                    .mutable(),
                self.inner.cap,
            )
        };
        // write item, tracking in tx
        tx.ctor_inplace(&mut r[self.inner.len], f)?;
        self.inner.get_mut(tx)?.len += 1;
        Ok(())
    }

    pub fn pop(&mut self, tx: &impl TxHandle) -> Result<T> {
        todo!()
    }
}

mod tests {
    use super::*;
    use crate::{
        marker::{BaseType, Invariant},
        object::TypedObject,
        ptr::{GlobalPtr, InvPtr},
    };

    #[derive(Copy, Clone)]
    struct Simple {
        x: u32,
    }
    unsafe impl Invariant for Simple {}

    impl BaseType for Simple {}

    struct Node {
        ptr: InvPtr<Simple>,
    }

    // will be auto-generated by a derive macro
    impl Node {
        pub fn new_inplace(
            place: &mut MaybeUninit<Self>,
            ptr: impl Into<GlobalPtr<Simple>>,
        ) -> crate::tx::Result<()> {
            todo!()
        }
    }

    impl BaseType for Node {}
    unsafe impl Invariant for Node {}

    fn simple_push() {
        let vobj = ObjectBuilder::default()
            .build_inplace(|mut uo| Vec::new_inplace(uo.base_mut(), VecObjectAlloc))
            .unwrap();

        let tx = vobj.tx().unwrap();
        tx.base().push(Simple { x: 42 }, &tx);
        let vobj = tx.commit().unwrap();

        let base = vobj.base();
        let item = base.get(0).unwrap();
        assert_eq!(item.x, 42);
    }

    fn node_push() {
        let simple_obj = ObjectBuilder::default().build(Simple { x: 3 }).unwrap();
        let vobj = ObjectBuilder::<Vec<Node, VecObjectAlloc>>::default()
            .build_with(|_uo| Vec::new_in(VecObjectAlloc))
            .unwrap();

        let tx = vobj.tx().unwrap();
        tx.base()
            .push_inplace(|place| Node::new_inplace(place, simple_obj.base()), &tx);
        let vobj = tx.commit().unwrap();

        let base = vobj.base();
        let item = base.get(0).unwrap();
        assert_eq!(item.ptr.resolve().x, 3);
    }
}
